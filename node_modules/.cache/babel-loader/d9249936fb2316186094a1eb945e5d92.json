{"ast":null,"code":"'use strict';\n\nvar xtend = require('xtend');\n\nvar svg = require('property-information/svg');\n\nvar find = require('property-information/find');\n\nvar spaces = require('space-separated-tokens');\n\nvar commas = require('comma-separated-tokens');\n\nvar entities = require('stringify-entities');\n\nvar ccount = require('ccount');\n\nvar all = require('./all');\n\nvar constants = require('./constants');\n\nmodule.exports = serializeElement;\n\nfunction serializeElement(ctx, node, index, parent) {\n  var schema = ctx.schema;\n  var omit = schema.space === 'svg' ? false : ctx.omit;\n  var parts = [];\n  var selfClosing = schema.space === 'svg' ? ctx.closeEmpty : ctx.voids.indexOf(node.tagName.toLowerCase()) > -1;\n  var attrs;\n  var content;\n  var last;\n\n  if (schema.space === 'html' && node.tagName === 'svg') {\n    ctx.schema = svg;\n  }\n\n  attrs = serializeAttributes(ctx, node.properties);\n  content = all(ctx, schema.space === 'html' && node.tagName === 'template' ? node.content : node);\n  ctx.schema = schema; // If the node is categorised as void, but it has children, remove the\n  // categorisation.\n  // This enables for example `menuitem`s, which are void in W3C HTML but not\n  // void in WHATWG HTML, to be stringified properly.\n\n  if (content) selfClosing = false;\n\n  if (attrs || !omit || !omit.opening(node, index, parent)) {\n    parts.push('<', node.tagName, attrs ? ' ' + attrs : '');\n\n    if (selfClosing && (schema.space === 'svg' || ctx.close)) {\n      last = attrs.charAt(attrs.length - 1);\n\n      if (!ctx.tightClose || last === '/' || schema.space === 'svg' && last && last !== '\"' && last !== \"'\") {\n        parts.push(' ');\n      }\n\n      parts.push('/');\n    }\n\n    parts.push('>');\n  }\n\n  parts.push(content);\n\n  if (!selfClosing && (!omit || !omit.closing(node, index, parent))) {\n    parts.push('</' + node.tagName + '>');\n  }\n\n  return parts.join('');\n}\n\nfunction serializeAttributes(ctx, props) {\n  var values = [];\n  var index = -1;\n  var key;\n  var value;\n  var last;\n\n  for (key in props) {\n    if (props[key] != null) {\n      value = serializeAttribute(ctx, key, props[key]);\n      if (value) values.push(value);\n    }\n  }\n\n  while (++index < values.length) {\n    last = ctx.tight ? values[index].charAt(values[index].length - 1) : null; // In tight mode, don’t add a space after quoted attributes.\n\n    if (index !== values.length - 1 && last !== '\"' && last !== \"'\") {\n      values[index] += ' ';\n    }\n  }\n\n  return values.join('');\n}\n\nfunction serializeAttribute(ctx, key, value) {\n  var info = find(ctx.schema, key);\n  var quote = ctx.quote;\n  var result;\n  var name;\n\n  if (info.overloadedBoolean && (value === info.attribute || value === '')) {\n    value = true;\n  } else if (info.boolean || info.overloadedBoolean && typeof value !== 'string') {\n    value = Boolean(value);\n  }\n\n  if (value == null || value === false || typeof value === 'number' && value !== value) {\n    return '';\n  }\n\n  name = entities(info.attribute, xtend(ctx.entities, {\n    // Always encode without parse errors in non-HTML.\n    subset: constants.name[ctx.schema.space === 'html' ? ctx.valid : 1][ctx.safe]\n  })); // No value.\n  // There is currently only one boolean property in SVG: `[download]` on\n  // `<a>`.\n  // This property does not seem to work in browsers (FF, Sa, Ch), so I can’t\n  // test if dropping the value works.\n  // But I assume that it should:\n  //\n  // ```html\n  // <!doctype html>\n  // <svg viewBox=\"0 0 100 100\">\n  //   <a href=https://example.com download>\n  //     <circle cx=50 cy=40 r=35 />\n  //   </a>\n  // </svg>\n  // ```\n  //\n  // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>\n\n  if (value === true) return name;\n  value = typeof value === 'object' && 'length' in value ? // `spaces` doesn’t accept a second argument, but it’s given here just to\n  // keep the code cleaner.\n  (info.commaSeparated ? commas.stringify : spaces.stringify)(value, {\n    padLeft: !ctx.tightLists\n  }) : String(value);\n  if (ctx.collapseEmpty && !value) return name; // Check unquoted value.\n\n  if (ctx.unquoted) {\n    result = entities(value, xtend(ctx.entities, {\n      subset: constants.unquoted[ctx.valid][ctx.safe],\n      attribute: true\n    }));\n  } // If we don’t want unquoted, or if `value` contains character references when\n  // unquoted…\n\n\n  if (result !== value) {\n    // If the alternative is less common than `quote`, switch.\n    if (ctx.smart && ccount(value, quote) > ccount(value, ctx.alternative)) {\n      quote = ctx.alternative;\n    }\n\n    result = quote + entities(value, xtend(ctx.entities, {\n      // Always encode without parse errors in non-HTML.\n      subset: (quote === \"'\" ? constants.single : constants.double)[ctx.schema.space === 'html' ? ctx.valid : 1][ctx.safe],\n      attribute: true\n    })) + quote;\n  } // Don’t add a `=` for unquoted empties.\n\n\n  return name + (result ? '=' + result : result);\n}","map":null,"metadata":{},"sourceType":"script"}