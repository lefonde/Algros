{"ast":null,"code":"'use strict';\n\nvar s = require('hastscript/svg');\n\nvar h = require('hastscript');\n\nvar find = require('property-information/find');\n\nvar html = require('property-information/html');\n\nvar svg = require('property-information/svg');\n\nvar vfileLocation = require('vfile-location');\n\nvar ns = require('web-namespaces');\n\nmodule.exports = wrapper;\nvar own = {}.hasOwnProperty; // Handlers.\n\nvar map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n}; // Wrapper to normalise options.\n\nfunction wrapper(ast, options) {\n  var settings = options || {};\n  var file;\n\n  if (settings.messages) {\n    file = settings;\n    settings = {};\n  } else {\n    file = settings.file;\n  }\n\n  return transform(ast, {\n    schema: settings.space === 'svg' ? svg : html,\n    file: file,\n    verbose: settings.verbose\n  });\n} // Transform a node.\n\n\nfunction transform(ast, config) {\n  var schema = config.schema;\n  var fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element;\n  var children;\n  var result;\n  var position;\n\n  if (fn === element) {\n    config.schema = ast.namespaceURI === ns.svg ? svg : html;\n  }\n\n  if (ast.childNodes) {\n    children = nodes(ast.childNodes, config);\n  }\n\n  result = fn(ast, children, config);\n\n  if (ast.sourceCodeLocation && config.file) {\n    position = location(result, ast.sourceCodeLocation, config);\n\n    if (position) {\n      config.location = true;\n      result.position = position;\n    }\n  }\n\n  config.schema = schema;\n  return result;\n} // Transform children.\n\n\nfunction nodes(children, config) {\n  var index = -1;\n  var result = [];\n\n  while (++index < children.length) {\n    result[index] = transform(children[index], config);\n  }\n\n  return result;\n} // Transform a document.\n// Stores `ast.quirksMode` in `node.data.quirksMode`.\n\n\nfunction root(ast, children, config) {\n  var result = {\n    type: 'root',\n    children: children,\n    data: {\n      quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'\n    }\n  };\n  var doc;\n  var location;\n\n  if (config.file && config.location) {\n    doc = String(config.file);\n    location = vfileLocation(doc);\n    result.position = {\n      start: location.toPoint(0),\n      end: location.toPoint(doc.length)\n    };\n  }\n\n  return result;\n} // Transform a doctype.\n\n\nfunction doctype(ast) {\n  return {\n    type: 'doctype',\n    name: ast.name || '',\n    public: ast.publicId || null,\n    system: ast.systemId || null\n  };\n} // Transform a text.\n\n\nfunction text(ast) {\n  return {\n    type: 'text',\n    value: ast.value\n  };\n} // Transform a comment.\n\n\nfunction comment(ast) {\n  return {\n    type: 'comment',\n    value: ast.data\n  };\n} // Transform an element.\n\n\nfunction element(ast, children, config) {\n  var fn = config.schema.space === 'svg' ? s : h;\n  var props = {};\n  var index = -1;\n  var result;\n  var attribute;\n  var pos;\n  var start;\n  var end;\n\n  while (++index < ast.attrs.length) {\n    attribute = ast.attrs[index];\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] = attribute.value;\n  }\n\n  result = fn(ast.tagName, props, children);\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    pos = ast.sourceCodeLocation;\n    start = pos && pos.startTag && position(pos.startTag).end;\n    end = pos && pos.endTag && position(pos.endTag).start;\n    result.content = transform(ast.content, config);\n\n    if ((start || end) && config.file) {\n      result.content.position = {\n        start: start,\n        end: end\n      };\n    }\n  }\n\n  return result;\n} // Create clean positional information.\n\n\nfunction location(node, location, config) {\n  var result = position(location);\n  var tail;\n  var key;\n  var props;\n\n  if (node.type === 'element') {\n    tail = node.children[node.children.length - 1]; // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n\n    if (!location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n\n    if (config.verbose) {\n      props = {};\n\n      for (key in location.attrs) {\n        props[find(config.schema, key).property] = position(location.attrs[key]);\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n\n  return result;\n}\n\nfunction position(loc) {\n  var start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  var end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  });\n  return start || end ? {\n    start: start,\n    end: end\n  } : null;\n}\n\nfunction point(point) {\n  return point.line && point.column ? point : null;\n}","map":null,"metadata":{},"sourceType":"script"}